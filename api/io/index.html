
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://pyjanitor-devs.github.io/pyjanitor/api/io/">
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-8.5.2">
    
    
      
        <title>Input/Output (io) - pyjanitor documentation</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.9f9400aa.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.cbb835fc.min.css">
        
          
          
          <meta name="theme-color" content="#546d78">
        
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../assets/_mkdocstrings.css">
    
      <link rel="stylesheet" href="../../css/nb_mods.css">
    
      <link rel="stylesheet" href="../../css/apidocs.css">
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/nord.min.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="blue-grey" data-md-color-accent="blue-grey">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#inputoutput-io" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="pyjanitor documentation" class="md-header__button md-logo" aria-label="pyjanitor documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M96 0C43 0 0 43 0 96v320c0 53 43 96 96 96h320c17.7 0 32-14.3 32-32s-14.3-32-32-32v-64c17.7 0 32-14.3 32-32V32c0-17.7-14.3-32-32-32H96zm0 384h256v64H96c-17.7 0-32-14.3-32-32s14.3-32 32-32zm32-240c0-8.8 7.2-16 16-16h192c8.8 0 16 7.2 16 16s-7.2 16-16 16H144c-8.8 0-16-7.2-16-16zm16 48h192c8.8 0 16 7.2 16 16s-7.2 16-16 16H144c-8.8 0-16-7.2-16-16s7.2-16 16-16z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            pyjanitor documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Input/Output (io)
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/pyjanitor-devs/pyjanitor" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    pyjanitor-devs/pyjanitor
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="pyjanitor documentation" class="md-nav__button md-logo" aria-label="pyjanitor documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M96 0C43 0 0 43 0 96v320c0 53 43 96 96 96h320c17.7 0 32-14.3 32-32s-14.3-32-32-32v-64c17.7 0 32-14.3 32-32V32c0-17.7-14.3-32-32-32H96zm0 384h256v64H96c-17.7 0-32-14.3-32-32s14.3-32 32-32zm32-240c0-8.8 7.2-16 16-16h192c8.8 0 16 7.2 16 16s-7.2 16-16 16H144c-8.8 0-16-7.2-16-16zm16 48h192c8.8 0 16 7.2 16 16s-7.2 16-16 16H144c-8.8 0-16-7.2-16-16s7.2-16 16-16z"/></svg>

    </a>
    pyjanitor documentation
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/pyjanitor-devs/pyjanitor" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    pyjanitor-devs/pyjanitor
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../devguide/" class="md-nav__link">
        Development Guide
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          API Reference
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="API Reference" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          API Reference
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../functions/" class="md-nav__link">
        Functions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../biology/" class="md-nav__link">
        Biology
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../chemistry/" class="md-nav__link">
        Chemistry
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../engineering/" class="md-nav__link">
        Engineering
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../finance/" class="md-nav__link">
        Finance
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Input/Output (io)
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Input/Output (io)
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#janitor.io" class="md-nav__link">
    janitor.io
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.io.read_commandline" class="md-nav__link">
    read_commandline()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.io.read_csvs" class="md-nav__link">
    read_csvs()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.io.xlsx_cells" class="md-nav__link">
    xlsx_cells()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.io.xlsx_table" class="md-nav__link">
    xlsx_table()
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../ml/" class="md-nav__link">
        Machine Learning
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../math/" class="md-nav__link">
        Math
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../timeseries/" class="md-nav__link">
        Timeseries
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../utils/" class="md-nav__link">
        Utils
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../xarray/" class="md-nav__link">
        XArray
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../CHANGELOG/" class="md-nav__link">
        Changelog
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../AUTHORS/" class="md-nav__link">
        Authors
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#janitor.io" class="md-nav__link">
    janitor.io
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.io.read_commandline" class="md-nav__link">
    read_commandline()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.io.read_csvs" class="md-nav__link">
    read_csvs()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.io.xlsx_cells" class="md-nav__link">
    xlsx_cells()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.io.xlsx_table" class="md-nav__link">
    xlsx_table()
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  <a href="https://github.com/pyjanitor-devs/pyjanitor/edit/master/docs/api/io.md" title="Edit this page" class="md-content__button md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25Z"/></svg>
  </a>


<h1 id="inputoutput-io">Input/Output (io)</h1>


  <div class="doc doc-object doc-module">

<a id="janitor.io"></a>
    <div class="doc doc-contents first">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h2 id="janitor.io.read_commandline" class="doc doc-heading">
<code class="highlight language-python">read_commandline(cmd, **kwargs)</code>


</h2>

    <div class="doc doc-contents ">

      <p>Read a CSV file based on a command-line command.</p>
<p>For example, you may wish to run the following command on <code>sep-quarter.csv</code>
before reading it into a pandas DataFrame:</p>
<pre><code class="language-bash">cat sep-quarter.csv | grep .SEA1AA
</code></pre>
<p>In this case, you can use the following Python code to load the dataframe:</p>
<pre><code class="language-python">import janitor as jn
df = jn.read_commandline(&quot;cat data.csv | grep .SEA1AA&quot;)
</code></pre>
<p>This function assumes that your command line command will return
an output that is parsable using <code>pandas.read_csv</code> and StringIO.
We default to using <code>pd.read_csv</code> underneath the hood.
Keyword arguments are passed through to read_csv.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>cmd</code></td>
        <td><code>str</code></td>
        <td><p>Shell command to preprocess a file on disk.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>kwargs</code></td>
        <td></td>
        <td><p>Keyword arguments that are passed through to <code>pd.read_csv()</code>.</p></td>
        <td><code>{}</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>pd.DataFrame</code></td>
      <td><p>A pandas DataFrame parsed from the stdout of the underlying shell.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/io.py</code></summary>
          <pre class="highlight"><code class="language-python">def read_commandline(cmd: str, **kwargs) -&gt; pd.DataFrame:
    """
    Read a CSV file based on a command-line command.

    For example, you may wish to run the following command on `sep-quarter.csv`
    before reading it into a pandas DataFrame:

    ```bash
    cat sep-quarter.csv | grep .SEA1AA
    ```

    In this case, you can use the following Python code to load the dataframe:

    ```python
    import janitor as jn
    df = jn.read_commandline("cat data.csv | grep .SEA1AA")
    ```

    This function assumes that your command line command will return
    an output that is parsable using `pandas.read_csv` and StringIO.
    We default to using `pd.read_csv` underneath the hood.
    Keyword arguments are passed through to read_csv.

    :param cmd: Shell command to preprocess a file on disk.
    :param kwargs: Keyword arguments that are passed through to
        `pd.read_csv()`.
    :returns: A pandas DataFrame parsed from the stdout of the underlying
        shell.
    """

    check("cmd", cmd, [str])
    # adding check=True ensures that an explicit, clear error
    # is raised, so that the user can see the reason for the failure
    outcome = subprocess.run(
        cmd, shell=True, capture_output=True, text=True, check=True
    )
    return pd.read_csv(StringIO(outcome.stdout), **kwargs)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="janitor.io.read_csvs" class="doc doc-heading">
<code class="highlight language-python">read_csvs(files_path, separate_df=False, **kwargs)</code>


</h2>

    <div class="doc doc-contents ">

      <p>Read multiple CSV files and return a dictionary of DataFrames, or
one concatenated DataFrame.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>files_path</code></td>
        <td><code>Union[str, Iterable[str]]</code></td>
        <td><p>The filepath pattern matching the CSV files. Accepts regular expressions, with or without <code>.csv</code> extension. Also accepts iterable of file paths.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>separate_df</code></td>
        <td><code>bool</code></td>
        <td><p>If <code>False</code> (default), returns a single Dataframe with the concatenation of the csv files. If <code>True</code>, returns a dictionary of separate DataFrames for each CSV file.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>kwargs</code></td>
        <td></td>
        <td><p>Keyword arguments to pass into the original pandas <code>read_csv</code>.</p></td>
        <td><code>{}</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Union[pd.DataFrame, dict]</code></td>
      <td><p>DataFrame of concatenated DataFrames or dictionary of DataFrames.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>JanitorError</code></td>
        <td><p>if <code>None</code> provided for <code>files_path</code>.</p></td>
      </tr>
      <tr>
        <td><code>JanitorError</code></td>
        <td><p>if length of <code>files_path</code> is <code>0</code>.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if no CSV files exist in <code>files_path</code>.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if columns in input CSV files do not match.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/io.py</code></summary>
          <pre class="highlight"><code class="language-python">@deprecated_alias(seperate_df="separate_df", filespath="files_path")
def read_csvs(
    files_path: Union[str, Iterable[str]], separate_df: bool = False, **kwargs
) -&gt; Union[pd.DataFrame, dict]:
    """
    Read multiple CSV files and return a dictionary of DataFrames, or
    one concatenated DataFrame.

    :param files_path: The filepath pattern matching the CSV files.
        Accepts regular expressions, with or without `.csv` extension.
        Also accepts iterable of file paths.
    :param separate_df: If `False` (default), returns a single Dataframe
        with the concatenation of the csv files.
        If `True`, returns a dictionary of separate DataFrames
        for each CSV file.
    :param kwargs: Keyword arguments to pass into the
        original pandas `read_csv`.
    :returns: DataFrame of concatenated DataFrames or dictionary of DataFrames.
    :raises JanitorError: if `None` provided for `files_path`.
    :raises JanitorError: if length of `files_path` is `0`.
    :raises ValueError: if no CSV files exist in `files_path`.
    :raises ValueError: if columns in input CSV files do not match.
    """
    # Sanitize input
    if files_path is None:
        raise JanitorError("`None` provided for `files_path`")
    if not files_path:
        raise JanitorError("0 length `files_path` provided")

    # Read the csv files
    # String to file/folder or file pattern provided
    if isinstance(files_path, str):
        dfs_dict = {
            os.path.basename(f): pd.read_csv(f, **kwargs)
            for f in glob(files_path)
        }
    # Iterable of file paths provided
    else:
        dfs_dict = {
            os.path.basename(f): pd.read_csv(f, **kwargs) for f in files_path
        }
    # Check if dataframes have been read
    if not dfs_dict:
        raise ValueError("No CSV files to read with the given `files_path`")
    # Concatenate the dataframes if requested (default)
    col_names = list(dfs_dict.values())[0].columns  # noqa: PD011
    if not separate_df:
        # If columns do not match raise an error
        for df in dfs_dict.values():  # noqa: PD011
            if not all(df.columns == col_names):
                raise ValueError(
                    "Columns in input CSV files do not match."
                    "Files cannot be concatenated."
                )
        return pd.concat(
            list(dfs_dict.values()),
            ignore_index=True,
            sort=False,  # noqa: PD011
            copy=False,
        )
    return dfs_dict
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="janitor.io.xlsx_cells" class="doc doc-heading">
<code class="highlight language-python">xlsx_cells(path, sheetnames=None, start_point=None, end_point=None, read_only=True, include_blank_cells=True, fill=False, font=False, alignment=False, border=False, protection=False, comment=False, **kwargs)</code>


</h2>

    <div class="doc doc-contents ">

      <p>Imports data from spreadsheet without coercing it into a rectangle.
Each cell is represented by a row in a dataframe, and includes the
cell's coordinates, the value, row and column position.
The cell formatting (fill, font, border, etc) can also be accessed;
usually this is returned as a dictionary in the cell, and the specific
cell format attribute can be accessed using <code>pd.Series.str.get</code>.</p>
<p>Inspiration for this comes from R's <a href="https://nacnudus.github.io/tidyxl/reference/tidyxl.html">tidyxl</a> package.</p>
<p>Example:</p>
<pre class="highlight"><code>&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from janitor import xlsx_cells
&gt;&gt;&gt; pd.set_option("display.max_columns", None)
&gt;&gt;&gt; pd.set_option("display.expand_frame_repr", False)
&gt;&gt;&gt; pd.set_option("max_colwidth", None)
&gt;&gt;&gt; filename = "../pyjanitor/tests/test_data/worked-examples.xlsx"

# Each cell is returned as a row:
&gt;&gt;&gt; xlsx_cells(filename, sheetnames="highlights")
    value internal_value coordinate  row  column data_type  is_date number_format
0     Age            Age         A1    1       1         s    False       General
1  Height         Height         B1    1       2         s    False       General
2       1              1         A2    2       1         n    False       General
3       2              2         B2    2       2         n    False       General
4       3              3         A3    3       1         n    False       General
5       4              4         B3    3       2         n    False       General
6       5              5         A4    4       1         n    False       General
7       6              6         B4    4       2         n    False       General

# Access cell formatting such as fill :
&gt;&gt;&gt; out=xlsx_cells(filename, sheetnames="highlights", fill=True).select_columns("value", "fill")
&gt;&gt;&gt; out
    value                                                                                                                                              fill
0     Age     {'patternType': None, 'fgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}, 'bgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}}
1  Height     {'patternType': None, 'fgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}, 'bgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}}
2       1     {'patternType': None, 'fgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}, 'bgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}}
3       2     {'patternType': None, 'fgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}, 'bgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}}
4       3  {'patternType': 'solid', 'fgColor': {'rgb': 'FFFFFF00', 'type': 'rgb', 'tint': 0.0}, 'bgColor': {'rgb': 'FFFFFF00', 'type': 'rgb', 'tint': 0.0}}
5       4  {'patternType': 'solid', 'fgColor': {'rgb': 'FFFFFF00', 'type': 'rgb', 'tint': 0.0}, 'bgColor': {'rgb': 'FFFFFF00', 'type': 'rgb', 'tint': 0.0}}
6       5     {'patternType': None, 'fgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}, 'bgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}}
7       6     {'patternType': None, 'fgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}, 'bgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}}

# specific cell attributes can be accessed by using Pandas' series.str.get :
&gt;&gt;&gt; out.fill.str.get("fgColor").str.get("rgb")
0    00000000
1    00000000
2    00000000
3    00000000
4    FFFFFF00
5    FFFFFF00
6    00000000
7    00000000
Name: fill, dtype: object


</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>path</code></td>
        <td><code>Union[str, Workbook]</code></td>
        <td><p>Path to the Excel File. It can also be an openpyxl Workbook.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>sheetnames</code></td>
        <td><code>Union[str, list, tuple]</code></td>
        <td><p>Names of the sheets from which the cells are to be extracted. If <code>None</code>, all the sheets in the file are extracted; if it is a string, or list or tuple, only the specified sheets are extracted.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>start_point</code></td>
        <td><code>Union[str, int]</code></td>
        <td><p>start coordinates of the Excel sheet. This is useful if the user is only interested in a subsection of the sheet. If start_point is provided, end_point must be provided as well.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>end_point</code></td>
        <td><code>Union[str, int]</code></td>
        <td><p>end coordinates of the Excel sheet. This is useful if the user is only interested in a subsection of the sheet. If end_point is provided, start_point must be provided as well.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>read_only</code></td>
        <td><code>bool</code></td>
        <td><p>Determines if the entire file is loaded in memory, or streamed. For memory efficiency, read_only should be set to <code>True</code>. Some cell properties like <code>comment</code>, can only be accessed by setting <code>read_only</code> to <code>False</code>.</p></td>
        <td><code>True</code></td>
      </tr>
      <tr>
        <td><code>include_blank_cells</code></td>
        <td><code>bool</code></td>
        <td><p>Determines if cells without a value should be included.</p></td>
        <td><code>True</code></td>
      </tr>
      <tr>
        <td><code>fill</code></td>
        <td><code>bool</code></td>
        <td><p>If <code>True</code>, return fill properties of the cell. It is usually returned as a dictionary.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>font</code></td>
        <td><code>bool</code></td>
        <td><p>If <code>True</code>, return font properties of the cell. It is usually returned as a dictionary.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>alignment</code></td>
        <td><code>bool</code></td>
        <td><p>If <code>True</code>, return alignment properties of the cell. It is usually returned as a dictionary.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>border</code></td>
        <td><code>bool</code></td>
        <td><p>If <code>True</code>, return border properties of the cell. It is usually returned as a dictionary.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>protection</code></td>
        <td><code>bool</code></td>
        <td><p>If <code>True</code>, return protection properties of the cell. It is usually returned as a dictionary.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>comment</code></td>
        <td><code>bool</code></td>
        <td><p>If <code>True</code>, return comment properties of the cell. It is usually returned as a dictionary.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>kwargs</code></td>
        <td></td>
        <td><p>Any other attributes of the cell, that can be accessed from openpyxl.</p></td>
        <td><code>{}</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Union[dict, pd.DataFrame]</code></td>
      <td><p>A pandas DataFrame, or a dictionary of DataFrames.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>If kwargs is provided, and one of the keys is a default column.</p></td>
      </tr>
      <tr>
        <td><code>AttributeError</code></td>
        <td><p>If kwargs is provided and any of the keys is not a openpyxl cell attribute.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/io.py</code></summary>
          <pre class="highlight"><code class="language-python">def xlsx_cells(
    path: Union[str, Workbook],
    sheetnames: Union[str, list, tuple] = None,
    start_point: Union[str, int] = None,
    end_point: Union[str, int] = None,
    read_only: bool = True,
    include_blank_cells: bool = True,
    fill: bool = False,
    font: bool = False,
    alignment: bool = False,
    border: bool = False,
    protection: bool = False,
    comment: bool = False,
    **kwargs,
) -&gt; Union[dict, pd.DataFrame]:
    """
    Imports data from spreadsheet without coercing it into a rectangle.
    Each cell is represented by a row in a dataframe, and includes the
    cell's coordinates, the value, row and column position.
    The cell formatting (fill, font, border, etc) can also be accessed;
    usually this is returned as a dictionary in the cell, and the specific
    cell format attribute can be accessed using `pd.Series.str.get`.

    Inspiration for this comes from R's [tidyxl][link] package.
    [link]: https://nacnudus.github.io/tidyxl/reference/tidyxl.html

    Example:

        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from janitor import xlsx_cells
        &gt;&gt;&gt; pd.set_option("display.max_columns", None)
        &gt;&gt;&gt; pd.set_option("display.expand_frame_repr", False)
        &gt;&gt;&gt; pd.set_option("max_colwidth", None)
        &gt;&gt;&gt; filename = "../pyjanitor/tests/test_data/worked-examples.xlsx"

        # Each cell is returned as a row:
        &gt;&gt;&gt; xlsx_cells(filename, sheetnames="highlights")
            value internal_value coordinate  row  column data_type  is_date number_format
        0     Age            Age         A1    1       1         s    False       General
        1  Height         Height         B1    1       2         s    False       General
        2       1              1         A2    2       1         n    False       General
        3       2              2         B2    2       2         n    False       General
        4       3              3         A3    3       1         n    False       General
        5       4              4         B3    3       2         n    False       General
        6       5              5         A4    4       1         n    False       General
        7       6              6         B4    4       2         n    False       General

        # Access cell formatting such as fill :
        &gt;&gt;&gt; out=xlsx_cells(filename, sheetnames="highlights", fill=True).select_columns("value", "fill")
        &gt;&gt;&gt; out
            value                                                                                                                                              fill
        0     Age     {'patternType': None, 'fgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}, 'bgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}}
        1  Height     {'patternType': None, 'fgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}, 'bgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}}
        2       1     {'patternType': None, 'fgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}, 'bgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}}
        3       2     {'patternType': None, 'fgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}, 'bgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}}
        4       3  {'patternType': 'solid', 'fgColor': {'rgb': 'FFFFFF00', 'type': 'rgb', 'tint': 0.0}, 'bgColor': {'rgb': 'FFFFFF00', 'type': 'rgb', 'tint': 0.0}}
        5       4  {'patternType': 'solid', 'fgColor': {'rgb': 'FFFFFF00', 'type': 'rgb', 'tint': 0.0}, 'bgColor': {'rgb': 'FFFFFF00', 'type': 'rgb', 'tint': 0.0}}
        6       5     {'patternType': None, 'fgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}, 'bgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}}
        7       6     {'patternType': None, 'fgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}, 'bgColor': {'rgb': '00000000', 'type': 'rgb', 'tint': 0.0}}

        # specific cell attributes can be accessed by using Pandas' series.str.get :
        &gt;&gt;&gt; out.fill.str.get("fgColor").str.get("rgb")
        0    00000000
        1    00000000
        2    00000000
        3    00000000
        4    FFFFFF00
        5    FFFFFF00
        6    00000000
        7    00000000
        Name: fill, dtype: object

    :param path: Path to the Excel File. It can also be an openpyxl Workbook.
    :param sheetnames: Names of the sheets from which the cells are to be extracted.
        If `None`, all the sheets in the file are extracted;
        if it is a string, or list or tuple, only the specified sheets are extracted.
    :param start_point: start coordinates of the Excel sheet. This is useful
        if the user is only interested in a subsection of the sheet.
        If start_point is provided, end_point must be provided as well.
    :param end_point: end coordinates of the Excel sheet. This is useful
        if the user is only interested in a subsection of the sheet.
        If end_point is provided, start_point must be provided as well.
    :param read_only: Determines if the entire file is loaded in memory,
        or streamed. For memory efficiency, read_only should be set to `True`.
        Some cell properties like `comment`, can only be accessed by
        setting `read_only` to `False`.
    :param include_blank_cells: Determines if cells without a value should be included.
    :param fill: If `True`, return fill properties of the cell.
        It is usually returned as a dictionary.
    :param font: If `True`, return font properties of the cell.
        It is usually returned as a dictionary.
    :param alignment: If `True`, return alignment properties of the cell.
        It is usually returned as a dictionary.
    :param border: If `True`, return border properties of the cell.
        It is usually returned as a dictionary.
    :param protection: If `True`, return protection properties of the cell.
        It is usually returned as a dictionary.
    :param comment: If `True`, return comment properties of the cell.
        It is usually returned as a dictionary.
    :param kwargs: Any other attributes of the cell, that can be accessed from openpyxl.
    :raises ValueError: If kwargs is provided, and one of the keys is a default column.
    :raises AttributeError: If kwargs is provided and any of the keys
        is not a openpyxl cell attribute.
    :returns: A pandas DataFrame, or a dictionary of DataFrames.
    """  # noqa : E501

    try:
        from openpyxl import load_workbook
        from openpyxl.cell.read_only import ReadOnlyCell
        from openpyxl.cell.cell import Cell
        from openpyxl.workbook.workbook import Workbook
    except ImportError:
        import_message(
            submodule="io",
            package="openpyxl",
            conda_channel="conda-forge",
            pip_install=True,
        )

    path_is_workbook = isinstance(path, Workbook)
    if not path_is_workbook:
        # for memory efficiency, read_only is set to True
        # if comments is True, read_only has to be False,
        # as lazy loading is not enabled for comments
        if comment and read_only:
            raise ValueError(
                "To access comments, kindly set 'read_only' to False."
            )
        path = load_workbook(
            filename=path, read_only=read_only, keep_links=False
        )
    # start_point and end_point applies if the user is interested in
    # only a subset of the Excel File and knows the coordinates
    if start_point or end_point:
        check("start_point", start_point, [str, int])
        check("end_point", end_point, [str, int])

    defaults = (
        "value",
        "internal_value",
        "coordinate",
        "row",
        "column",
        "data_type",
        "is_date",
        "number_format",
    )

    parameters = {
        "fill": fill,
        "font": font,
        "alignment": alignment,
        "border": border,
        "protection": protection,
        "comment": comment,
    }

    if kwargs:
        if path_is_workbook:
            if path.read_only:
                _cell = ReadOnlyCell
            else:
                _cell = Cell
        else:
            if read_only:
                _cell = ReadOnlyCell
            else:
                _cell = Cell

        attrs = {
            attr
            for attr, _ in inspect.getmembers(_cell, not (inspect.isroutine))
            if not attr.startswith("_")
        }

        for key in kwargs:
            if key in defaults:
                raise ValueError(
                    f"{key} is part of the default attributes "
                    "returned as a column."
                )
            elif key not in attrs:
                raise AttributeError(
                    f"{key} is not a recognized attribute of {_cell}."
                )
        parameters.update(kwargs)

    if not sheetnames:
        sheetnames = path.sheetnames
    elif isinstance(sheetnames, str):
        sheetnames = [sheetnames]
    else:
        check("sheetnames", sheetnames, [str, list, tuple])

    out = {
        sheetname: _xlsx_cells(
            path[sheetname],
            defaults,
            parameters,
            start_point,
            end_point,
            include_blank_cells,
        )
        for sheetname in sheetnames
    }
    if len(out) == 1:
        _, out = out.popitem()

    if (not path_is_workbook) and path.read_only:
        path.close()

    return out
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="janitor.io.xlsx_table" class="doc doc-heading">
<code class="highlight language-python">xlsx_table(path, sheetname, table=None)</code>


</h2>

    <div class="doc doc-contents ">

      <p>Returns a DataFrame of values in a table in the Excel file.
This applies to an Excel file, where the data range is explicitly
specified as a Microsoft Excel table.</p>
<p>If there is a single table in the sheet, or a string is provided
as an argument to the <code>table</code> parameter, a pandas DataFrame is returned;
if there is more than one table in the sheet,
and the <code>table</code> argument is <code>None</code>, or a list/tuple of names,
a dictionary of DataFrames is returned, where the keys of the dictionary
are the table names.</p>
<p>Example:</p>
<pre class="highlight"><code>&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from janitor import xlsx_table
&gt;&gt;&gt; filename="../pyjanitor/tests/test_data/016-MSPTDA-Excel.xlsx"

# single table
&gt;&gt;&gt; xlsx_table(filename, sheetname='Tables', table='dCategory')
   CategoryID       Category
0           1       Beginner
1           2       Advanced
2           3      Freestyle
3           4    Competition
4           5  Long Distance

# multiple tables:
&gt;&gt;&gt; out=xlsx_table(filename, sheetname="Tables", table=["dCategory", "dSalesReps"])
&gt;&gt;&gt; out["dCategory"]
   CategoryID       Category
0           1       Beginner
1           2       Advanced
2           3      Freestyle
3           4    Competition
4           5  Long Distance
&gt;&gt;&gt; out["dSalesReps"].head(3)
   SalesRepID             SalesRep Region
0           1  Sioux Radcoolinator     NW
1           2        Tyrone Smithe     NE
2           3         Chantel Zoya     SW


</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>path</code></td>
        <td><code>Union[str, Workbook]</code></td>
        <td><p>Path to the Excel File. It can also be an openpyxl Workbook.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>sheetname</code></td>
        <td><code>str</code></td>
        <td><p>Name of the sheet from which the tables are to be extracted.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>table</code></td>
        <td><code>Union[str, list, tuple]</code></td>
        <td><p>Name of a table, or list of tables in the sheet.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Union[pd.DataFrame, dict]</code></td>
      <td><p>A pandas DataFrame, or a dictionary of DataFrames, if there are multiple arguments for the <code>table</code> parameter, or the argument to <code>table</code> is <code>None</code>.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>AttributeError</code></td>
        <td><p>If a workbook is provided, and is a ReadOnlyWorksheet.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>If there are no tables in the sheet.</p></td>
      </tr>
      <tr>
        <td><code>KeyError</code></td>
        <td><p>If the provided table does not exist in the sheet.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/io.py</code></summary>
          <pre class="highlight"><code class="language-python">def xlsx_table(
    path: Union[str, Workbook],
    sheetname: str,
    table: Union[str, list, tuple] = None,
) -&gt; Union[pd.DataFrame, dict]:
    """
    Returns a DataFrame of values in a table in the Excel file.
    This applies to an Excel file, where the data range is explicitly
    specified as a Microsoft Excel table.

    If there is a single table in the sheet, or a string is provided
    as an argument to the `table` parameter, a pandas DataFrame is returned;
    if there is more than one table in the sheet,
    and the `table` argument is `None`, or a list/tuple of names,
    a dictionary of DataFrames is returned, where the keys of the dictionary
    are the table names.

    Example:

        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from janitor import xlsx_table
        &gt;&gt;&gt; filename="../pyjanitor/tests/test_data/016-MSPTDA-Excel.xlsx"

        # single table
        &gt;&gt;&gt; xlsx_table(filename, sheetname='Tables', table='dCategory')
           CategoryID       Category
        0           1       Beginner
        1           2       Advanced
        2           3      Freestyle
        3           4    Competition
        4           5  Long Distance

        # multiple tables:
        &gt;&gt;&gt; out=xlsx_table(filename, sheetname="Tables", table=["dCategory", "dSalesReps"])
        &gt;&gt;&gt; out["dCategory"]
           CategoryID       Category
        0           1       Beginner
        1           2       Advanced
        2           3      Freestyle
        3           4    Competition
        4           5  Long Distance
        &gt;&gt;&gt; out["dSalesReps"].head(3)
           SalesRepID             SalesRep Region
        0           1  Sioux Radcoolinator     NW
        1           2        Tyrone Smithe     NE
        2           3         Chantel Zoya     SW

    :param path: Path to the Excel File. It can also be an openpyxl Workbook.
    :param sheetname: Name of the sheet from which the tables
        are to be extracted.
    :param table: Name of a table, or list of tables in the sheet.
    :returns: A pandas DataFrame, or a dictionary of DataFrames,
        if there are multiple arguments for the `table` parameter,
        or the argument to `table` is `None`.
    :raises AttributeError: If a workbook is provided, and is a ReadOnlyWorksheet.
    :raises ValueError: If there are no tables in the sheet.
    :raises KeyError: If the provided table does not exist in the sheet.


    """  # noqa : E501

    try:
        from openpyxl import load_workbook
        from openpyxl.workbook.workbook import Workbook
    except ImportError:
        import_message(
            submodule="io",
            package="openpyxl",
            conda_channel="conda-forge",
            pip_install=True,
        )
    if isinstance(path, Workbook):
        ws = path[sheetname]
    else:
        ws = load_workbook(
            filename=path, read_only=False, keep_links=False, data_only=True
        )
        ws = ws[sheetname]

    try:
        contents = ws.tables
    except AttributeError as error:
        raise AttributeError(
            "Accessing the tables is not supported for ReadOnlyWorksheet"
        ) from error

    if not contents:
        raise ValueError(f"There is no table in '{sheetname}' sheet.")

    class TableArgs(NamedTuple):
        """
        Named Tuple to easily index values
        from the tables in the sheet.
        """

        table_name: str
        ref: str
        headerRowCount: int

    if isinstance(table, str):
        table = [table]
    if table is not None:
        check("table", table, [str, list, tuple])
        try:
            data = []
            for key in table:
                outcome = TableArgs(
                    key, contents[key].ref, contents[key].headerRowCount
                )
                data.append(outcome)
        except KeyError as error:
            raise KeyError(
                f"Table {error} is not in the '{sheetname}' sheet."
            ) from error
    else:
        data = (
            TableArgs(key, contents[key].ref, contents[key].headerRowCount)
            for key in contents
        )

    frame = {}
    for table_arg in data:
        content = [[cell.value for cell in row] for row in ws[table_arg.ref]]

        if table_arg.headerRowCount:
            header, *content = content
        else:
            header = [f"C{num}" for num in range(len(content[0]))]
        frame[table_arg.table_name] = pd.DataFrame(
            content, columns=header, copy=False
        )

    if len(frame) == 1:
        _, frame = frame.popitem()
    return frame
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
    <nav class="md-footer__inner md-grid" aria-label="Footer" >
      
        
        <a href="../finance/" class="md-footer__link md-footer__link--prev" aria-label="Previous: Finance" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              Finance
            </div>
          </div>
        </a>
      
      
        
        <a href="../ml/" class="md-footer__link md-footer__link--next" aria-label="Next: Machine Learning" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              Machine Learning
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["instant"], "search": "../../assets/javascripts/workers/search.ecf98df9.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.39f04ddb.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
      
        <script src="../../js/config.js"></script>
      
    
  </body>
</html>